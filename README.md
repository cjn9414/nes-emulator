# nes-emulator
My attempt at making an emulator for the Nintendo Entertainment System.

## Status
Development is currently in progress! Feel free to check the recent commits to see what I have been working on.

## Motives
I really want to learn much more about low-level programming, specifically programming in C. Upon searching for project ideas, I came across a [gameboy emulator](https://cturt.github.io/cinoop.html) that really caught my eye. As a huge fan of the Nintendo Entertainment System, I thought I would try my hand at making an emulator for it.

## Legal
I am in no way advocating the use of illegally obtained software with this emulator. I will not and cannot supply any software to use with this emulator. Any use of this emulator is under the assumption that the owner of the software that is being used has given permission to use it freely. All the information used in the development of this emulator was legally obtained and is credited in this file. **It is illegal to run any software on this emulator for which you do not own a license for.**

# NES Overview

## Reference
* All of the information in the hardware section that follows was found [here](http://www.nesdev.com/NESDoc.pdf). I have simply taken notes on what was found from this manual, highlighting the key points that I found most important.
* The opcodes that were used to simulate the 6502 processor was foud [here](http://www.6502.org/tutorials/6502opcodes.html#ADC).


## Hardware
* NES uses memory mapped I/O for the CPU to communicate to other components
### 8-bit 2A03 processor as the CPU
* Very similar to 8-bit 6502, but is equipped to handle sound, but lacking BCD ability.
* Little endian processor - addresses are stored in memory least significant byte first
* Supports 64 KB of memory ($0000-$FFFF)
  * Zero Page - ($0000-$00FF) - used by certain addressing modes to allow for quicker execution
  * $0000-$07FF mirrored at $0800-$0FFF, $1000-$17FF, and $1800-$1FFF
  * Memory mapped I/O registers located at $2000-$401F. Locations $2000-$2007 are mirrored every eight bytes, from $2008-$3FFF, with the remaining registers following this mirroring.
  * Additional I/O registers located at $4000-$401F
  * Expansion ROM from  $4020-$5FFF
  * SRAM from $6000-$7FFF
  * $8000-$FFFF are the addresses allocated to cartridge PRG-ROM.
    * Games with one 16 KB bank - Load bank into both $8000 and $C000
    * Games with two 16 KB banks - Load one into $8000 and the other into $C000
    * Games with more than two 16 KB banks - Memory mappers used to determine banks that are loaded
* Three special purpose registers
  * The program counter
    * 16-bit register to hold address of the next instruction to be executed
  * The stack pointer
    * The stack is located at $0100-$01FF
    * Stack pointer is an 8-bit register at an offset from $0100
    * Stack pointer decremented when byte pushed onto stack, incremented when popped.
    * No detection of Stack Overflow (wraps from $00-$FF)
  * The status register
    * Carry Flag (C) - Set if last instruction caused overflow or underflow. Can be set using SEC (Set Carry Flag) instruction or cleared using CLC (Clear Carry Flag) instruction
    * Zero Flag (Z) - Set if the result of the last instruction resolved to 0
    * Interrupt Disable (I) - When set, prevents response to interrupt requests (IRQs). Set by SEI (Set Interrupt Disable) and cleared by CLI (Clear Interrupt Disable)
    * Decimal Mode (D) - Switches into BCD, but ignored in the 2A03 because it is not supported
    * Break Command (B) - Indicates execution of a BRK (break) instruction, which causes an IRQ
    * Overflow Flag (V) - Set if an invalid two's compliment result was obtained
    * Negative Flag (N) - Set if the sign bit of a byte is set to 1
    * From bit 7 to bit 0, flags are arranged like NV-BDIZC (bit 5 is unused)

* Three general purpose registers
  * The accumulator
    * 8-bit register to store result of arithmetic operations, can also be set to a value from memory
  * Index registers (X and Y) to store data or temporarily control information
    * X register is an 8-bit register usually used as a counter or an offset. Can be set to a value from memory, or used to get/set the value of the stack pointer
    * Y register is identical in size and usage as the X register, but cannot affect the stack pointer
* Three types of interrupts
  * IRQ
    * Generated by memory mappers
    * Ignored if interrupt disable flag is set
    * Can be triggered by software by use of BRK instruction.
    * When IRQ occurs, the system jumps to address located at $FFFE-$FFFF
  * NMI (Non-Maskable Interrupt)
    * Generated by the PPU when V-blank occurs at the end of each frame
    * Not affected by interrupt disable bit. However, NMI can be disregarded if bit 7 of of PPU control register 1 ($2000 is clear)
    * When NMI occurs, the system jumps to address located at $FFFA and $FFFB
  * Reset Interrupt
    * Triggered when system first starts and when the user presses the reset button.
    * When reset occurs, the system jumps to address located at $FFFC and $FFFD
  * System priority given to reset, followed by NMI, and lastly IRQ.
  * NES has an interrupt latency of 7 cycles (takes 7 CPU cycles to begin executing the interrupt handler)
* 13 different addressing modes
* 56 different instructions, with some coming in multiple variations due to different addressing modes, totaling 151 valid opcodes.
  * Instructions are either one, two or three bytes long. The first byte is the opcode, and the remaining bytes are the operands. Functional groups of instructions shown below:
    * Load / Store Operations - Load register from memory or store contents of register from memory.
    * Register Transfer Operations - Copy contents of X / Y register to accumulator or visa versa.
    * Stack Operations - Push or pop the stack, or manipulate stack pointer using X register.
    * Logical Operations - Perform logical operations on the accumulator and a value stored in memory.
    * Arithmetic Operations - Perform arithmetic operations on registers and memory.
    * Increments / Decrements - Increment or decrement X / Y register, or a value stored in memory.
    * Shifts - Shift the bits of the accumulator, or a memory location one bit to the left or right.
    * Jumps / Calls - Break sequential execution sequence, resuming from a specified address.
    * Branches - Break sequential execution sequence, resuming from a specified address if a condition is met (involves examining specific bit in the status register).
    * Status Register Operations - Set or clear a flag in the status register.
    * System Functions - Perform rarely used functions.
### 8-bit 2CO2 processor as the PPU
* Registers are mostly located in the I/O registers section ($2000-$2007 and $4014)
  * Additional special registers used for screen scrolling
* Has its own memory (VRAM) 
  * Can address 64 KB of memory, but only has 16 KB of RAM
  * Any address above $3FFF is wrapped around ($4000-$FFFF) becomes a mirror of locations $0000-$3FFF
  * Reading and writing to memory is done using I/O registers at $2006 and $2007 in CPU memory
    * This is done using V-Blank at the end of a frame, as it affects addresses used while drawing the screen.
* PPU memory uses 16-bit addresses but I/O registers only use 8 bits
  * As a result, two writes to $2006 are required to set the address.
    * Data can then be read from or written to $2007
    * After each write to $2007, the address is either incremented by 1 or 32 (dependent on bit 2 of $2000)
* PPU also has a separate 256 byte area of memory to store sprite attributes (SPR-RAM). Sprites can be found in pattern tables
* Registers used by PPU are located in main memory at $2000-$2007 with an additional register at $4014, used for Direct Memory Access
* PPU actions can be controlled by CPU by writing to $2000 and $2001, known as PPU Control Register 1 and 2 respectively
  * The control registers should only be written to by the CPU, never read
  * Bit 7 of $2000 can be used to disable NMIs
  * Setting bit 5 of $2000 will switch to 8x16 sprites, otherwise the system will be supporting 8x8 sprites
  * The next address in PPU memory to read from or write to will be incremented after each I/O.
  * Bit 2 of $2000 controls the incremental value of the address that is read from or written to
    * If clear, then the address is incremented by 1 (horizontal)
    * If set, then the address is incremented by 32 (vertical)
    * Clearing bit 3 or bit 4 of $2001 will hide the background or the sprites, respectively.
* The PPU Status Register is located at $2002 (read only)
  * Used to report status to the CPU
  * CPU frequently reads from this address to obtain PPU status
  * Bit 7 is set by the PPU to indicate that a V-Blank is occurring
  * Bit 4 is set to indicate PPU's willingness to access writes to VRAM
  * When a read from $2002 occurs, bit 7 is reset to 0 as well as $2005 and $2006
* Direct Memory Access (DMA) is a technique for more efficient copying of data from CPU memory to sprite memory
  * The whole of sprite memory can be filled by using a single write to $4014
  * Starting address in CPU memory is specified by the operand for the write multiplied by $100. The 256 bytes starting at this address are copied directly into sprite memory without additional intervention of the CPU
  * DMA uses memory bus, preventing CPU from using it during this time. This prevents CPU from accessing any more instructions (cycle stealing)
    * DMA takes the equivalent of about 512 cycles, or about 4.5 scanlines worth
* PPU color palette
  * Contains 52 colors although there is actually room for 64.
  * Not every color can be displayed at a given time
  * Two palettes with 16 entries are used (an image palette and a sprite palette)
    * Image palette shows colors available for background tiles at $3F00-$3F0F
    * Sprite palette shows colors available for sprites at $3F10-$3F1F
    * Palettes don't store the color, but store the index of the color in the system palette
    * Both palettes are mirrored to $3F20-$3FFF
  * Bits 6 and 7 are ignored since only 64 unique values are needed
  * Palette entry at $3F00 is the background color and is used for transparency
    * Every four bytes is a mirror of $3F00 from $3F04-$3F1C
      * This means there are actually only 13 total possible colors in each palette rather than 16
      * The total number of possible onscreen colors is then 25 out of a total of 52
* Two pattern tables located at $0000 and $1000 in PPU memory
  * Stores 8x8 pixel tiles which can be drawn on screen
  * Some games store pattern tables on CHR-ROM on the cartridge
    * Games lacking pattern tables on the CHR-ROM use RAM for this, filling the pattern tables during execution
  * The pattern tables collectively store the least significant two bits of the 4-bit number that identifies the image/sprite palette used by that pixel
    * With respect to the values at a location in the first and second sprite table:
      * 00b is palette entry 0
      * 01b is palette entry 1
      * 10b is palette entry 2
      * 11b is palette entry 3
  * The other two bits of the color are taken from the attribute tables
* PPU name tables
  * Name tables are a matrix of tile numbers pointing to the tiles stored in the pattern tables.
  * Name tables are 32x30 tiles (each tile is 8x8 pixels, meaning the name table is 256x240 pixels)
  * Name table has an associated attribute table
* PPU attribute tables
  * Attribute tables hold the upper two bits of the colors for the tiles
  * Each byte in the attribute table represents a 4x4 group of tiles
    * Attribute table resolves to an 8x8 table of these groups of tiles
  * Each 4x4 group is further divided into four 2x2 squares.
* NES has 2 KB to store name tables and attribute tables (two of each)
  * NES can address up to four of each using mirroring
  * There are four types of name table mirroring:
    * Addressable name tables abbreviated as L1 at $2000, L2 at $2400, L3 at $2800, and L4 at $2C00
    * Horizontal mirroring - maps L1 and L2 to first physical name table and L3 and L4 to the second name table
    * Vertical mirroring - maps L1 and L3 to the first physical name table and L2 and L4 to the second name table
    * Single-screen mirroring - points all four logical name tables to the same physical name table
    * Four-screen mirroring - uses additional 2 KB of ram in game cartridge to allow each logical name table to occupy independent physical name table
* Sprites
  * Can either be 8x8 pixels or 8x16 pixels
  * The sprite data is stored in the pattern tables, and sprite attributes are stored in SPR-RAM
  * Maximum of 64 sprites, each using four bytes in SPR-RAM
    * Byte 0 - Stores y-coordinate of the top-left of the sprite minus one
    * Byte 1 - Index number of the sprite in the pattern tables
    * Byte 2 - Stores that attributes of the sprite
      * Bits 0-1 - Most significant two bits of the color
      * Bit 5 - Indicates if the sprite has priority over the background
      * Bit 6 - Indicates whether to flip the sprite horizontally
      * Bit 7 - Indicates whether to flip the sprite vertically
  * 8x16 sprites use different pattern tables based on their index number
    * An even index number indicates the sprite data is located in the first pattern table at $0000
    * An odd index number indicates the sprite data is located in the second pattern table at $1000
  * Sprites can be read or written one at a time by first writing the address to $2003 and then reading or writing $2004
    * As an alternative, the entirety of SPR-RAM can be written in one DMA operation by writing to $4014'
  * Sprites given priority by their position in SPR-RAM
    * The first sprite, sprite 0 has a higher priority
    * On each line, the system draws sprites from lower to higher priority
    * Eight sprites are allowed per scanline
      * System indicates maximum sprites on scanline by setting bit 5 of I/O register $2002
  * Scrolling technique involves determining whether sprite 0 is overlapping a non-transparent background pixel
    * If sprite 0 is being drawn and a non-transparent pixel overlaps a non-transparent background pixel, the system sets the sprite 0 hit flag in bit 6 of $2002
    * If background tile contains only transparent pixels bit 6 should never be set
  * Since characters are generally larger than a single sprite, characters constructed using multiple sprites
* Scrolling
  * Background can be scrolled horizontally or vertically
  * Scrolling makes use of the separate name tables
  * Background taken from either one or two name tables at any given time
  * The system maintains a 16-bit VRAM address register, which is set by $2006
    * Bits 0-11 store the address of the name table as an offset from $2000
      * Bits 0-4 are the x-scroll, incremented as the lines are drawn. This will wrap from 31 to 0, switching bit 10
      * Bits 5-9 are the y-scroll, incremented at the end of the line. This will wrap from 29 to 0, switching bit 11
      * A write to $2007 to set the value above 29 will wrap to 0 when reaching 31, but bit 11 will not be affected
      * Bits 12-14 are the tile y-offset
  * Tile numbers indicated by x-scroll and y-scroll, allowing 32 tiles (256 pixels) by 30 tiles (240 pixels), totaling 960 tiles
  * There is a second temporary VRAM address register that is also 16-bits long. There is also a 3-bit tile x-offset
    * Both are updated by writes to registers and as the frame is drawn
* Television standards
  * Different versions of the system were created for two different television formats (NTSC and PAL)
  * Images on screens displayed by stream of electrons which light the screen left to right
  * A single line of pixels referred to as a scanline
  * H-Blank - time taken for electron to move to a new line and to the left at the end of a scanline
  * V-Blank - time taken for electron to move back to top left of the screen after drawing the entire screen
    * PPU indicates V-Blank period by setting bit 7 of I/O register $2002. This bit is then reset when the CPU next reads from $2002
  * NTSC version contains 240 scanlines
    * Top and bottom eight lines are cut off
    * Takes additional 3 scanlines worth of CPU cycles to enter V-Blank
    * V-Blank period takes additional 20 scanlines worth of CPU cycles before the next frame is ready to be drawn
### Game Hardware
* Cartridges
  * NES games come on a ROM chip inside a Game Pak
  * Some cartridges also feature RAM powered by a battery, which allow the game to be saved
  * Cartridge connects to NES via a 72-pin connector
  * Cartridge contains CHR-ROM chip to store pattern tables (graphics data for the game)
  * Cartridge contains PRG-ROM chip to store program code for the game
* Memory Mapper (MMC) - Switching hardware in game cartridges to allow the NES to swap data in and out of memory given the limited addressing of the NES
  * When the system requires access to data on ROM bank that isn't currently loaded into memory, software indicates need to switch banks
    * The selected bank is then loaded into memory and replaces the existing contents
  * UNROM switches allow switching of only PRG-ROM banks
    * Maximum number of 16 KB PRG-ROM banks using UNROM is 8
  * CNROM switches allow switching of only CHR-ROM banks
  * MMC1 allowed switching of both CHR-ROM and PRG-ROM banks
    * Also allowed changes to name table mirroring and had support for saving to a RAM chip.
    * Maximum number of 16 KB PRG-ROM banks using MMC1 is 8
  * MMC3 allowed switching of both CHR-ROM and PRG-ROM banks
    * Also allowed for selective screen scrolling (allowing part of the screen to move while part remains stationary)
    * Was also capable of generating IRQs
    * Maximum number of 16 KB PRG-ROM banks using MMC3 is 32
* Cartridge File Formats
  * iNES file format is the most commonly used file format for ROM images for emulation
    * Should have file extension *.nes
    * Format provides 16 byte header at the start of the file
      * Bytes 0-2 - contains the string "NES" to identify iNES file
      * Byte 3 - should contain the value $1A to identify file format
      * Byte 4 - number of 16 KB PRG-ROM banks (area used to store program code)
      * Byte 5 - number of 8 KB CHR-ROM banks (area used to store graphics information and pattern tables)
      * Byte 6 - ROM Control Byte 1
       	* Bit 0 - type of mirroring used by game - 0 for horizontal mirroring, 1 for vertical mirroring
	      * Bit 1 - indicates presence of battery-backed RAM at locations $6000-$7FFF
	      * Bit 2 - indicates presence of 512-byte trainer at locations $7000-$71FF
	      * Bit 3 - set to indicate override of bit 0, which would indicate four-screen mirroring to be used
	      * Bits 4-7 - four lower bits of mapper number
      * Byte 7 - ROM Control Byte 2
        * Bits 0-3 - reserved for future usage (should all be 0)
	      * Bits 4-7 - four upper bits of mapper number
      * Byte 8 - number of 8 KB RAM banks (assume 1 page of RAM when this byte is 0)
      * Bytes 9-15 - reserved for future usage (should all be 0)
    * Following the header is the 512-byte trainer if one is present
    * The ROM banks will then follow, starting with PRG-ROM and then CHR-ROM.
    * This format allows for up to 256 different memory mappers
    * Each mapper is assigned a specific number
      * Obtained by shifting bits 4-7 of control byte 2 to the left by four bits, then adding bits 4-7 of control byte 1
  * UNIF file format (Universal NES Interchange Format)
    * Should have file extension *.unf
    * Header contains format and revision number, followed by a series of chunks
      * Each chunk consists of an ID string to identify purpose of the chunk, the length in bytes, and the data
      * Format similar to XML
    * Identifies each mapper from the name of the board used rather than via a number
      * Ensures only genuine boards can be used
    * Although UNIF improves on iNES format, it is currently supported by fewer emulators and less ROM files available for the format
      * iNES should be replaced by UNIF eventually
* Input Devices
  * Control Pad
    * The same instructions and bus are used to communicate with I/O devices as with memory
    * Writing to a specific memory location writes to the appropriate device
    * The I/O ports for input devices were $4016 and $4017
    * The system reads multiple times from I/O port to get all information about the controller
    * Each of the first eight reads indicates the status of a button on the standard controller
      * The order of reads goes A, B, Select, Start, Up, Down, Left, Right
    * First controller attached to port $4016, and the second to $4017
    * Reads 17-20 retrieve signatures to identify if a device is connected, and the type of device if so.
      * If a joypad is connected to $4016 the returned value is 01b, if connected to $4017 the return value is 10b
    * There are four more reads that are not used before the cycle starts again
    * Process of reading from an I/O device can be reset by strobing method
      * When a reset is required, it is indicated by writing a 1 to a port followed by a 0
