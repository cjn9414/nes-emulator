# nes-emulator
My attempt at making an emulator for the Nintendo Entertainment System.

## Motives
I really want to learn much more about low-level programming, specifically programming in C. Upon searching for project ideas, I came across a [gameboy emulator](https://cturt.github.io/cinoop.html) that really caught my eye. As a huge fan of the Nintendo Entertainment System, I thought I would try my hand at making an emulator for it.

# NES Overview

## Reference
All of the information that follows was found [here](http://www.nesdev.com/NESDoc.pdf). I have simply taken notes on what was found from this manual, highlighting the aspects that I found most important.

## Hardware
* NES uses memory mapped I/O for the CPU to communicate to other components
### 8-bit 2A03 processor as the CPU
* Very similar to 8-bit 6502, but is equipped to handle sound, but lacking BCD ability.
* Little endian processor - addresses are stored in memory least significant byte first
* Supports 64 KB of memory ($0000-$FFFF)
  * Zero Page - ($0000-$00FF) - used by certain addressing modes to allow for quicker execution
  * $0000-$07FF mirrored at $0800-$0FFF, $1000-$17FF, and $1800-$1FFF
  * Memory mapped I/O registers located at $2000-$401F. Locations $2000-$2007 are mirrored every eight bytes, from $2008-$3FFF, with the remaining registers following this mirroring.
  * Additional I/O registers located at $4000-$401F
  * Expansion ROM from  $4020-$5FFF
  * SRAM from $6000-$7FFF
  * $8000-$FFFF are the addresses allocated to cartridge PRG-ROM.
    * Games with one 16 KB bank - Load bank into both $8000 and $C000
    * Games with two 16 KB banks - Load one into $8000 and the other into $C000
    * Games with more than two 16 KB banks - Memory mappers used to determine banks that are loaded
* Three special purpose registers
  * The program counter
    * 16-bit register to hold address of the next instruction to be executed
  * The stack pointer
    * The stack is located at $0100-$01FF
    * Stack pointer is an 8-bit register at an offset from $0100
    * Stack pointer decremented when byte pushed onto stack, incremented when popped.
    * No detection of Stack Overflow (wraps from $00-$FF)
  * The status register
    * Carry Flag (C) - Set if last instruction caused overflow or underflow. Can be set using SEC (Set Carry Flag) instruction or cleared using CLC (Clear Carry Flag) instruction
    * Zero Flag (Z) - Set if the result of the last instruction resolved to 0
    * Interrupt Disable (I) - When set, prevents response to interrupt requests (IRQs). Set by SEI (Set Interrupt Disable) and cleared by CLI (Clear Interrupt Disable)
    * Decimal Mode (D) - Switches into BCD, but ignored in the 2A03 because it is not supported
    * Break Command (B) - Indicates execution of a BRK (break) instruction, which causes an IRQ
    * Overflow Flag (V) - Set if an invalid two's compliment result was obtained
    * Negative Flag (N) - Set if the sign bit of a byte is set to 1
    * From bit 7 to bit 0, flags are arranged like NV-BDIZC (bit 5 is unused)

* Three general purpose registers
* The accumulator
  * 8-bit register to store result of arithmetic operations, can also be set to a value from memory
* Index registers (X and Y) to store data or temporarily control information
  * X register is an 8-bit register usually used as a counter or an offset. Can be set to a value from memory, or used to get/set the value of the stack pointer
  * Y register is identical in size and usage as the X register, but cannot affect the stack pointer
* Three types of interrupts
  * IRQ
    * Generated by memory mappers
    * Ignored if interrupt disable flag is set
    * Can be triggered by software by use of BRK instruction.
    * When IRQ occurs, the system jumps to address located at $FFFE-$FFFF
  * NMI (Non-Maskable Interrupt)
    * Generated by the PPU when V-blank occurs at the end of each frame
    * Not affected by interrupt disable bit. However, NMI can be disregarded if bit 7 of of PPU control register 1 ($2000 is clear)
    * When NMI occurs, the system jumps to address located at $FFFA and $FFFB
  * Reset Interrupt
    * Triggered when system first starts and when the user presses the reset button.
    * When reset occurs, the system jumps to address located at $FFFC and $FFFD
  * System priority given to reset, followed by NMI, and lastly IRQ.
  * NES has an interrupt latency of 7 cycles (takes 7 CPU cycles to begin executing the interrupt handler)
* 13 different addressing modes
* 56 different instructions, with some coming in multiple variations due to different addressing modes, totaling 151 valid opcodes.
  * Instructions are either one, two or three bytes long. The first byte is the opcode, and the remaining bytes are the operands. Functional groups of instructions shown below:
    * Load / Store Operations - Load register from memory or store contents of register from memory.
    * Register Transfer Operations - Copy contents of X / Y register to accumulator or visa versa.
    * Stack Operations - Push or pop the stack, or manipulate stack pointer using X register.
    * Logical Operations - Perform logical operations on the accumulator and a value stored in memory.
    * Arithmetic Operations - Perform arithmetic operations on registers and memory.
    * Increments / Decrements - Increment or decrement X / Y register, or a value stored in memory.
    * Shifts - Shift the bits of the accumulator, or a memory location one bit to the left or right.
    * Jumps / Calls - Break sequential execution sequence, resuming from a specified address.
    * Branches - Break sequential execution sequence, resuming from a specified address if a condition is met (involves examining specific bit in the status register).
    * Status Register Operations - Set or clear a flag in the status register.
    * System Functions - Perform rarely used functions.
### 8-bit 2CO2 processor as the PPU
* Registers are mostly located in the I/O registers section ($2000-$2007 and $4014)
  * Additional special registers used for screen scrolling
* Has its own memory (VRAM) 
  * Can address 64 KB of memory, but only has 16 KB of RAM
  * Any address above $3FFF is wrapped around ($4000-$FFFF) becomes a mirror of locations $0000-$3FFF
  * Reading and writing to memory is done using I/O registers at $2006 and $2007 in CPU memory
    * This is done using V-Blank at the end of a frame, as it affects addresses used while drawing the screen.
* PPU memory uses 16-bit addresses but I/O registers only use 8 bits
  * As a result, two writes to $2006 are required to set the address.
    * Data can then be read from or written to $2007
    * After each write to $2007, the address is either incremented by 1 or 32 (dependent on bit 2 of $2000)
* PPU also has a separate 256 byte area of memory to store sprite attributes (SPR-RAM). Sprites can be found in pattern tables
* Registers used by PPU are located in main memory at $2000-$2007 with an additional register at $4014, used for Direct Memory Access
* PPU actions can be controlled by CPU by writing to $2000 and $2001, known as PPU Control Register 1 and 2 respectively
  * The control registers should only be written to by the CPU, never read
  * Bit 7 of $2000 can be used to disable NMIs
  * Setting bit 5 of $2000 will switch to 8x16 sprites, otherwise the system will be supporting 8x8 sprites
  * The next address in PPU memory to read from or write to will be incremented after each I/O.
  * Bit 2 of $2000 controls the incremental value of the address that is read from or written to
    * If clear, then the address is incremented by 1 (horizontal)
    * If set, then the address is incremented by 32 (vertical)
    * Clearing bit 3 or bit 4 of $2001 will hide the background or the sprites, respectively.
* The PPU Status Register is located at $2002 (read only)
  * Used to report status to the CPU
  * CPU frequently reads from this address to obtain PPU status
  * Bit 7 is set by the PPU to indicate that a V-Blank is occurring
  * Bit 4 is set to indicate PPU's willingness to access writes to VRAM
  * When a read from $2002 occurs, bit 7 is reset to 0 as well as $2005 and $2006
* Direct Memory Access (DMA) is a technique for more efficient copying of data from CPU memory to sprite memory
  * The whole of sprite memory can be filled by using a single write to $4014
  * Starting address in CPU memory is specified by the operand for the write multiplied by $100. The 256 bytes starting at this address are copied directly into sprite memory without additional intervention of the CPU
  * DMA uses memory bus, preventing CPU from using it during this time. This prevents CPU from accessing any more instructions (cycle stealing)
    * DMA takes the equivalent of about 512 cycles, or about 4.5 scanlines worth
* PPU color palette
  * Contains 52 colors although there is actually room for 64.
  * Not every color can be displayed at a given time
  * Two palettes with 16 entries are used (an image palette and a sprite palette)
    * Image palette shows colors available for background tiles at $3F00-$3F0F
    * Sprite palette shows colors available for sprites at $3F10-$3F1F
    * Palettes don't store the color, but store the index of the color in the system palette
    * Both palettes are mirrored to $3F20-$3FFF
  * Bits 6 and 7 are ignored since only 64 unique values are needed
  * Palette entry at $3F00 is the background color and is used for transparency
    * Every four bytes is a mirror of $3F00 from $3F04-$3F1C
      * This means there are actually only 13 total possible colors in each palette rather than 16
      * The total number of possible onscreen colors is then 25 out of a total of 52
* Two pattern tables located at $0000 and $1000 in PPU memory
  * Stores 8x8 pixel tiles which can be drawn on screen
  * Some games store pattern tables on CHR-ROM on the cartridge
    * Games lacking pattern tables on the CHR-ROM use RAM for this, filling the pattern tables during execution
  * The pattern tables collectively store the least significant two bits of the 4-bit number that identifies the image/sprite palette used by that pixel
    * With respect to the values at a location in the first and second sprite table:
      * 00b is palette entry 0
      * 01b is palette entry 1
      * 10b is palette entry 2
      * 11b is palette entry 3
  * The other two bits of the color are taken from the attribute tables
* PPU name tables
  * Name tables are a matrix of tile numbers pointing to the tiles stored in the pattern tables.
  * Name tables are 32x30 tiles (each tile is 8x8 pixels, meaning the name table is 256x240 pixels)
  * Name table has an associated attribute table
* PPU attribute tables
  * Attribute tables hold the upper two bits of the colors for the tiles
  * Each byte in the attribute table represents a 4x4 group of tiles
    * Attribute table resolves to an 8x8 table of these groups of tiles
  * Each 4x4 group is further divided into four 2x2 squares.
* NES has 2 KB to store name tables and attribute tables (two of each)
  * NES can address up to four of each using mirroring
  * There are four types of name table mirroring:
    * Addressable name tables abbreviated as L1 at $2000, L2 at $2400, L3 at $2800, and L4 at $2C00
    * Horizontal mirroring - maps L1 and L2 to first physical name table and L3 and L4 to the second name table
    * Vertical mirroring - maps L1 and L3 to the first physical name table and L2 and L4 to the second name table
    * Single-screen mirroring - points all four logical name tables to the same physical name table
    * Four-screen mirroring - uses additional 2 KB of ram in game cartridge to allow each logical name table to occupy independent physical name table
* Sprites
  * Can either be 8x8 pixels or 8x16 pixels
  * The sprite data is stored in the pattern tables, and sprite attributes are stored in SPR-RAM
  * Maximum of 64 sprites, each using four bytes in SPR-RAM
    * Byte 0 - Stores y-coordinate of the top-left of the sprite minus one
    * Byte 1 - Index number of the sprite in the pattern tables
    * Byte 2 - Stores that attributes of the sprite
      * Bits 0-1 - Most significant two bits of the color
      * Bit 5 - Indicates if the sprite has priority over the background
      * Bit 6 - Indicates whether to flip the sprite horizontally
      * Bit 7 - Indicates whether to flip the sprite vertically
  * 8x16 sprites use different pattern tables based on their index number
    * An even index number indicates the sprite data is located in the first pattern table at $0000
    * An odd index number indicates the sprite data is located in the second pattern table at $1000
  * Sprites can be read or written one at a time by first writing the address to $2003 and then reading or writing $2004
    * As an alternative, the entirety of SPR-RAM can be written in one DMA operation by writing to $4014'
  * Sprites given priority by their position in SPR-RAM
    * The first sprite, sprite 0 has a higher priority
    * On each line, the system draws sprites from lower to higher priority
    * Eight sprites are allowed per scanline
      * System indicates maximum sprites on scanline by setting bit 5 of I/O register $2002
  * Scrolling technique involves determining whether sprite 0 is overlapping a non-transparent background pixel
    * If sprite 0 is being drawn and a non-transparent pixel overlaps a non-transparent background pixel, the system sets the sprite 0 hit flag in bit 6 of $2002
    * If background tile contains only transparent pixels bit 6 should never be set
  * Since characters are generally larger than a single sprite, characters constructed using multiple sprites
* Scrolling
  * Background can be scrolled horizontally or vertically
  * Scrolling makes use of the separate name tables
  * Background taken from either one or two name tables at any given time
  * The system maintains a 16-bit VRAM address register, which is set by $2006
    * Bits 0-11 store the address of the name table as an offset from $2000
      * Bits 0-4 are the x-scroll and is incremented as the lines are drawn. This will wrap from 31 to 0, switching bit 10
      * Bits 5-9 are the y-scroll and are incremented at the end of the line. This will wrap from 29 to 0, switching bit 11
      * A write to $2007 to set the value above 29 will wrap to 0 when reaching 31, but bit 11 will not be affected
      * Bits 12-14 are the tile y-offset
  * Tile numbers indicated by x-scroll and y-scroll, allowing 32 tiles (256 pixels) by 30 tiles (240 pixels), totaling 960 tiles
  * There is a second temporary VRAM address register that is also 16-bits long. There is also a 3-bit tile x-offset
    * Both are updated by writes to registers and as the frame is drawn
* Television standards
  * Different versions of the system were created for two different television formats (NTSC and PAL)
  * Images on screens displayed by stream of electrons which light the screen left to right
  * A single line of pixels referred to as a scanline
  * H-Blank - time taken for electron to move to a new line and to the left at the end of a scanline
  * V-Blank - time taken for electron to move back to top left of the screen after drawing the entire screen
    * PPU indicates V-Blank period by setting bit 7 of I/O register $2002. This bit is then reset when the CPU next reads from $2002
  * NTSC version contains 240 scanlines
    * Top and bottom eight lines are cut off
    * Takes additional 3 scanlines worth of CPU cycles to enter V-Blank
    * V-Blank period takes additional 20 scanlines worth of CPU cycles before the next frame is ready to be drawn
### Game Hardware
* Cartridges
  * NES games come on a ROM chip inside a Game Pak
  * Some cartridges also feature RAM powered by a battery, which allow the game to be saved
  * Cartridge connects to NES via a 72-pin connector
  * Cartridge contains CHR-ROM chip to store pattern tables (graphics data for the game)
  * Cartridge contains PRG-ROM chip to store program code for the game
* Memory Mapper (MMC) - Switching hardware in game cartridges to allow the NES to swap data in and out of memory given the limited addressing of the NES
  * When the system requires access to data on ROM bank that isn't currently loaded into memory, software indicates need to switch banks
    * The selected bank is then loaded into memory and replaces the existing contents
  * UNROM switches allow switching of only PRG-ROM banks
    * Maximum number of 16 KB PRG-ROM banks using UNROM is 8
  * CNROM switches allow switching of only CHR-ROM banks
  * MMC1 allowed switching of both CHR-ROM and PRG-ROM banks
    * Also allowed changes to name table mirroring and had support for saving to a RAM chip.
    * Maximum number of 16 KB PRG-ROM banks using MMC1 is 8
  * MMC3 allowed switching of both CHR-ROM and PRG-ROM banks
    * Also allowed for selective screen scrolling (allowing part of the screen to move while part remains stationary)
    * Was also capable of generating IRQs
    * Maximum number of 16 KB PRG-ROM banks using MMC3 is 32
* Cartridge File Formats
  * iNES file format is the most commonly used file format for ROM images for emulation
    * Should have file extension *.nes
    * Format provides 16 byte header at the start of the file
      * Bytes 0-2 - contains the string "NES" to identify iNES file
      * Byte 3 - should contain the value $1A to identify file format
      * Byte 4 - number of 16 KB PRG-ROM banks (area used to store program code)
      * Byte 5 - number of 8 KB CHR-ROM banks (area used to store graphics information and pattern tables)
      * Byte 6 - ROM Control Byte 1
       	* Bit 0 - type of mirroring used by game - 0 for horizontal mirroring, 1 for vertical mirroring
	* Bit 1 - indicates presence of battery-backed RAM at locations $6000-$7FFF
	* Bit 2 - indicates presence of 512-byte trainer at locations $7000-$71FF
	* Bit 3 - set to indicate override of bit 0, which would indicate four-screen mirroring to be used
	* Bits 4-7 - four lower bits of mapper number
      * Byte 7 - ROM Control Byte 2
        * Bits 0-3 - reserved for future usage (should all be 0)
	* Bits 4-7 - four upper bits of mapper number
      * Byte 8 - number of 8 KB RAM banks (assume 1 page of RAM when this byte is 0)
      * Bytes 9-15 - reserved for future usage (should all be 0)
    * Following the header is the 512-byte trainer if one is present
    * The ROM banks will then follow, starting with PRG-ROM and then CHR-ROM.
    * This format allows for up to 256 different memory mappers
    * Each mapper is assigned a specific number
      * Obtained by shifting bits 4-7 of control byte 2 to the left by four bits, then adding bits 4-7 of control byte 1
  * UNIF file format (Universal NES Interchange Format)
    * Should have file extension *.unf
    * Header contains format and revision number, followed by a series of chunks
      * Each chunk consists of an ID string to identify purpose of the chunk, the length in bytes, and the data
      * Format similar to XML
    * Identifies each mapper from the name of the board used rather than via a number
      * Ensures only genuine boards can be used
    * Although UNIF improves on iNES format, it is currently supported by fewer emulators and less ROM files available for the format
      * iNES should be replaced by UNIF eventually
* Input Devices
  * Control Pad
    * The same instructions and bus are used to communicate with I/O devices as with memory
    * Writing to a specific memory location writes to the appropriate device
    * The I/O ports for input devices were $4016 and $4017
    * The system reads multiple times from I/O port to get all information about the controller
    * Each of the first eight reads indicates the status of a button on the standard controller
      * The order of reads goes A, B, Select, Start, Up, Down, Left, Right
    * First controller attached to port $4016, and the second to $4017
    * Reads 17-20 retrieve signatures to identify if a device is connected, and the type of device if so.
      * If a joypad is connected to $4016 the returned value is 01b, if connected to $4017 the return value is 10b
    * There are four more reads that are not used before the cycle starts again
    * Process of reading from an I/O device can be reset by strobing method
      * When a reset is required, it is indicated by writing a 1 to a port followed by a 0
