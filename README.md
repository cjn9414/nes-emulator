# nes-emulator
My attempt at making an emulator for the Nintendo Entertainment System.

## Motives
I really want to learn much more about low-level programming, specifically programming in C. Upon searching for project ideas, I came across a [gameboy emulator](https://cturt.github.io/cinoop.html) that really caught my eye. As a huge fan of the Nintendo Entertainment System, I thought I would try my hand at making an emulator for it.

# NES Overview
## Hardware
* 8-bit 2A03 processor for the CPU, developed by NMOS technology
  * Very similar to 8-bit 6502, but is equipped to handle sound, but lacking BCD ability.
  * Little endian processor - addresses are stored in memory least significant byte first
  * Supports 64 KB of memory ($0000-$FFFF)
    * Zero Page - ($0000-$00FF) - used by certain addressing modes to allow for quicker execution
    * $0000-$07FF mirrored at $0800-$0FFF, $1000-$17FF, and $1800-$1FFF
    * Memory mapped I/O registers located at $2000-$401F. Locations $2000-$2007 are mirrored every eight bytes, from $2008-$3FFF, with the remaining registers following this mirroring.
    * Additional I/O registers located at $4000-$401F
    * Expansion ROM from  $4020-$5FFF
    * SRAM from $6000-$7FFF
    * $8000-$FFFF are the addresses allocated to cartridge PRG-ROM.
      * Games with one 16 KB bank - Load bank into both $8000 and $C000
      * Games with two 16 KB banks - Load one into $8000 and the other into $C000
      * Games with more than two 16 KB banks - Memory mappers used to determine banks that are loaded
  * Three special purpose registers
    * The program counter
      * 16-bit register to hold address of the next instruction to be executed
    * The stack pointer
      * The stack is located at $0100-$01FF
      * Stack pointer is an 8-bit register at an offset from $0100
      * Stack pointer decremented when byte pushed onto stack, incremented when popped.
      * No detection of Stack Overflow (wraps from $00-$FF)
    * The status register
      * Carry Flag (C) - Set if last instruction caused overflow or underflow. Can be set using SEC (Set Carry Flag) instruction or cleared using CLC (Clear Carry Flag) instruction
      * Zero Flag (Z) - Set if the result of the last instruction resolved to 0
      * Interrupt Disable (I) - When set, prevents response to interrupt requests (IRQs). Set by SEI (Set Interrupt Disable) and cleared by CLI (Clear Interrupt Disable)
      * Decimal Mode (D) - Switches into BCD, but ignored in the 2A03 because it is not supported
      * Break Command (B) - Indicates execution of a BRK (break) instruction, which causes an IRQ
      * Overflow Flag (V) - Set if an invalid two's compliment result was obtained
      * Negative Flag (N) - Set if the sign bit of a byte is set to 1
      * From bit 7 to bit 0, flags are arranged like NV_BDIZC (bit 5 is unused)

  * Three general purpose registers
  * The accumulator
    * 8-bit register to store result of arithmetic operations, can also be set to a value from memory
  * Index registers (X and Y) to store data or temporarily control information
    * X register is an 8-bit register usually used as a counter or an offset. Can be set to a value from memory, or used to get/set the value of the stack pointer
    * Y register is identical in size and usage as the X register, but cannot affect the stack pointer
  * Three types of interrupts
    * IRQ
      * Generated by memory mappers
      * Ignored if interrupt disable flag is set
      * Can be triggered by software by use of BRK instruction.
      * When IRQ occurs, the system jumps to address located at $FFFE-$FFFF
    * NMI (Non-Maskable Interrupt)
      * Generated by the PPU when V-blank occurs at the end of each frame
      * Not affected by interrupt disable bit. However, NMI can be disregarded if bit 7 of of PPU control register 1 ($2000 is clear)
      * When NMI occurs, the system jumps to address located at $FFFA and $FFFB
    * Reset Interrupt
      * Triggered when system first starts and when the user presses the reset button.
      * When reset occurs, the system jumps to address located at $FFFC and $FFFD
    * System priority given to reset, followed by NMI, and lastly IRQ.
    * NES has an interrupt latency of 7 cycles (takes 7 CPU cycles to begin executing the interrupt handler)
  * 13 different addressing modes
  * 56 different instructions, with some coming in multiple variations due to different addressing modes, totaling 151 valid opcodes.
    * Instructions are either one, two or three bytes long. The first byte is the opcode, and the remaining bytes are the operands. Functional groups of instructions shown below:
      * Load / Store Operations - Load register from memory or store contents of register from memory.
      * Register Transfer Operations - Copy contents of X / Y register to accumulator or visa versa.
      * Stack Operations - Push or pop the stack, or manipulate stack pointer using X register.
      * Logical Operations - Perform logical operations on the accumulator and a value stored in memory.
      * Arithmetic Operations - Perform arithmetic operations on registers and memory.
      * Increments / Decrements - Increment or decrement X / Y register, or a value stored in memory.
      * Shifts - Shift the bits of the accumulator, or a memory location one bit to the left or right.
      * Jumps / Calls - Break sequential execution sequence, resuming from a specified address.
      * Branches - Break sequential execution sequence, resuming from a specified address if a condition is met (involves examining specific bit in the status register).
      * Status Register Operations - Set or clear a flag in the status register.
      * System Functions - Perform rarely used functions.
* 8-bit 2CO2 processor for the PPU
  * Registers are mostly located in the I/O registers section ($2000-$2007 and $4014)
    * Additional special registers used for screen scrolling
  * Has its own memory (VRAM) 
    * Can address 64 KB of memory, but only has 16 KB of RAM
    * Any address above $3FFF is wrapped around ($4000-$FFFF) becomes a mirror of locations $0000-$3FFF
    * Reading and writing to memory is done using I/O registers at $2006 and $2007 in CPU memory
      * This is done using V-Blank at the end of a frame, as it affects addresses used while drawing the screen.
  * PPU memory uses 16-bit addresses but I/O registers only use 8 bits
    * As a result, two writes to $2006 are required to set the address.
      * Data can then be read from or written to $2007
      * After each write to $2007, the address is either incremented by 1 or 32 (dependent on bit 2 of $2000)
  * PPU also has a separate 256 byte area of memory to store sprite attributes (SPR-RAM). Sprites can be found in pattern tables
  

* NES uses memory mapped I/O for the CPU to communicate to other components


